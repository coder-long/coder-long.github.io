[{"title":"js向页面添加样式表，全局覆盖样式","url":"/2022/12/07/js向页面添加样式表，全局覆盖样式/","content":"\n### **js 向页面添加样式表，全局覆盖样式**\n\n\n\n```javascript\n const styleEl = document.createElement('style');\n //document.getElementsByTagName('head')[0].appendChild(styleEl);\n document.head.appendChild(styleEl);\n\n let cssRules = document.styleSheets[document.styleSheets.length - 1];\n\n cssRules.insertRule('body { color: #fff !important; }');\n\n```\n\n\n\n参考： https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/insertRule","tags":["CSS覆盖"]},{"title":"延迟加载图像-完整指南","url":"/2022/09/23/延迟加载图像-完整指南/","content":"## 什么是图像延迟加载？\n\n延迟加载图像是 Web 和应用程序开发中的一组技术，可将页面上的图像加载延迟到稍后的时间点 - 当实际需要这些图像时，而不是预先加载它们。这些技术有助于提高性能、更好地利用设备资源并降低相关成本。\n\n英语中的“懒惰”一词通常被归因于尽可能长时间避免工作的行为。\n\n同样，延迟加载将页面上的资源加载延迟到实际需要时。与通常情况下在页面加载后立即加载这些资源不同，这些资源的加载被推迟到用户实际需要查看它们的那一刻。\n\n延迟加载技术几乎可以应用于页面上的所有资源。例如，在单页应用程序中，如果一个 JS 文件直到以后才需要，最好[不要一开始就加载它](https://medium.com/front-end-hacking/lazy-loading-with-react-and-webpack-2-8e9e586cf442)。如果预先不需要图像，则在实际需要查看时稍后加载。\n\n## 为什么要延迟加载图像？\n\n延迟加载延迟加载页面上不需要的图像。图像在页面加载时对用户不可见，稍后在用户滚动并且图像实际变为可见时加载。如果用户从不滚动，则不会加载用户不可见的图像。\n\n它具有两个主要优点。\n\n**1. 性能提升**\n\n作为网站管理员，这对您来说是最重要的——更好的性能和加载时间。\n\n通过延迟加载，您可以减少最初需要在页面上加载的图像数量。更少的资源请求意味着更少的字节下载和更少的对用户可用的有限网络带宽的竞争。这确保了设备能够更快地下载和处理剩余资源。因此，与没有延迟加载的页面相比，页面可以更快地使用。\n\n**2. 降低成本**\n\n您的第二个好处是在交付成本方面。图像交付或任何其他资产的交付通常根据传输的字节数收费。\n\n如前所述，通过延迟加载，如果图像不可见，则永远不会加载。因此，您可以减少页面上传递的总字节数，尤其是对于从页面反弹或仅与页面顶部交互的用户。从您的交付网络传输的字节数减少会降低交付成本。随着我们进一步探索延迟加载，这将变得更加明显。\n\n## 哪些图像可以延迟加载？\n\n延迟加载的基本思想很简单——推迟加载现在不需要的任何内容。对于图像，它通常转换为用户不可见的任何图像，可以延迟加载。\n\n当用户向下滚动页面时，图像占位符开始进入视口（网页的可见部分）。当它们变得可见时，我们会触发这些图像的加载。\n\n[您可以使用Google Lighthouse 审计工具](https://developers.google.com/web/tools/lighthouse/)找出哪些图像适合延迟加载，以及在初始页面加载时可以节省多少字节。此工具执行的审核有一个专门用于[屏幕外图像](https://developers.google.com/web/tools/lighthouse/audits/offscreen-images)的部分。\n\n延迟加载不仅对于良好的性能至关重要，而且对于提供良好的用户体验也是至关重要的。\n\n## 图像的延迟加载技术\n\n可以通过两种方式加载网页上的图像 - 使用 <img> 标签，或使用 CSS `background` 属性。让我们先看看两者中比较常见的 <img> 标签，然后再看看 CSS 背景图片。\n\n### <img> 标签中延迟加载图片的一般概念\n\n延迟加载图像可以分为两个步骤：\n\n第一步是防止预先加载图像。对于使用`<img>`标签加载的图片，浏览器使用标签的`src`属性来触发图片加载。无论它是 HTML 中的第 1 个还是第 1000 个图像并且在屏幕外，如果浏览器获取该`src`属性，它将触发图像加载。\n\n因此，要延迟加载此类图像，请将图像 URL 放在除`src`. 假设我们在`data-src`图像标签的属性中指定了图像 URL。现在它`src`是空的，浏览器不会触发图像加载\n\n```html\n<img data-src=\"https://ik.imagekit.io/demo/default-image.jpg\" />\n```\n\n现在我们已经停止了前期加载，我们需要告诉浏览器何时加载图像。\n\n为此，我们检查一旦图像（即它的占位符）进入视口，我们就会触发加载。\n\n要检查图像何时进入视口，有两种方法：\n\n### 使用 Javascript 事件触发图像加载\n\n在这种技术中，我们在浏览器中使用事件监听`scroll`器`resize,`和`orientationChange`事件。当用户滚动页面时，滚动事件是一个显而易见的检查事件。resize 和orientationChange 事件对于延迟加载同样重要。当浏览器窗口的大小改变时，会发生 resize 事件。当设备从横向模式旋转到纵向模式时会触发orientationChange 事件，反之亦然。在这种情况下，屏幕上可见的图像数量会发生变化。因此，我们需要触发这些图像的加载。\n\n当这些事件中的任何一个发生时，我们会发现页面上所有要延迟加载且尚未加载的图像。从这些图像中，我们检查哪些图像现在在视口中。这是使用图像的顶部偏移量、当前文档滚动顶部和窗口高度来完成的。如果它已进入视口，我们从`data-src`属性中选择 URL 并将其放入`src`属性中。这会触发图像加载。我们还删除了`lazy`标识要为稍后触发的事件延迟加载的图像的类。加载所有图像后，我们将删除事件侦听器。\n\n> 当我们滚动时，滚动事件会快速触发多次。因此，为了性能，我们添加了一个小的超时来限制延迟加载函数的执行。\n\n这是这种方法的一个工作示例。\n\n<iframe height=\"265\" scrolling=\"no\" title=\"使用事件处理程序延迟加载图像 - 示例代码\" src=\"https://codepen.io/imagekit_io/embed/MBNwKB?height=265&amp;theme-id=default&amp;default-tab=js,result\" style=\"box-sizing: inherit; margin: 0px auto !important; padding: 0px; border: 0px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-weight: 400; font-stretch: inherit; line-height: inherit; font-family: Georgia, serif; font-size: 20px; vertical-align: middle; color: rgb(49, 59, 63); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; width: 100%;\"></iframe>\n\n\n如果您注意到，示例中的前 3 个图像是预先加载的。URL 直接存在于`src`属性中，而不是`data-src`属性中。这对于良好的用户体验至关重要。由于这些图像位于页面顶部，因此应尽快使它们可见。我们不能等待事件或 JS 执行来加载它们。\n\n### 使用 Intersection Observer API 触发图像加载\n\nIntersection Observer API 是浏览器中相对较新的 API。它使得检测元素何时进入视口并在它进入时采取行动变得非常简单。在之前的方法中，我们必须绑定事件，牢记性能，并实现一种计算元素是否在视口中的方法。Intersection Observer API 使这变得非常简单，有助于避免数学运算，并提供出色的性能。\n\n使用 Intersection Observer API 延迟加载图像的示例：\n\n我们将观察者附加到所有要延迟加载的图像上。一旦 API 检测到元素已进入视口，使用`isIntersecting`属性，我们从属性中选择 URL`data-src`并将其移动到`src`属性中以供浏览器触发图像加载。完成此操作后，我们从图像中删除惰性类，并从该图像中删除观察者。\n\n<iframe height=\"265\" scrolling=\"no\" title=\"使用 IntersectionObserver 延迟加载图像 - 示例代码\" src=\"https://codepen.io/imagekit_io/embed/BPXQZZ?height=265&amp;theme-id=default&amp;default-tab=js,result\" style=\"box-sizing: inherit; margin: 0px auto !important; padding: 0px; border: 0px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-weight: 400; font-stretch: inherit; line-height: inherit; font-family: Georgia, serif; font-size: 20px; vertical-align: middle; color: rgb(49, 59, 63); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; width: 100%;\"></iframe>\n\n\n如果您比较两种方法（事件侦听器与 Intersection Observer）加载图像所花费的时间，您会发现使用 Intersection Observer API，图像加载被触发得更快，而且网站在滚动时不会显得迟缓. 在涉及事件侦听器的方法中，我们必须添加超时以使其具有性能，这对用户体验的影响很小，因为图像加载被触发时会有轻微的延迟。\n\n但是，并非所有浏览器都[支持 Intersection Observer API 。](https://caniuse.com/#feat=intersectionobserver)因此，我们需要在不支持 Intersection Observer API 的浏览器中回退到事件侦听器方法。我们在上面的例子中已经考虑到了这一点。\n\n### 本机延迟加载\n\n在他们最近的更新中，谷歌在 Chrome 浏览器的最新版本 - Chrome 76 中增加了对原生延迟加载的支持。所有基于 Chromium 的浏览器，即 Chrome、Edge 和 Safari 以及 Firefox。[您可以在caniuse.com](https://caniuse.com/loading-lazy-attr)上找到有关浏览器支持本机延迟加载的更多详细信息。\n\n随着浏览器端的支持开始发挥作用，现在，开发者只需要在嵌入图像时添加一个“加载”属性，就可以在他们的网站上实现延迟加载。\n\n事实上，一个人甚至不需要成为一名开发人员来完成这项工作。HTML 的一些基本知识足以实现“加载”属性，使更多网站管理员可以访问此功能。\n\n所以代码现在看起来像 -\n\n```html\n<img src=\"example.jpg\" loading=\"lazy\" alt=\"...\" />\n<iframe src=\"example.html\" loading=\"lazy\"></iframe>\n```\n\nloading 属性支持以下值：\n\n- **lazy **推迟资产的加载，直到它与视口达到一定距离。\n- **eager**页面加载后立即加载资产，无论它们放置在页面上的哪个位置，无论是在页面折叠的上方还是下方。\n- **auto**此值触发默认延迟加载。基本上，它与不包括加载属性相同。\n\n但是，对于不支持本机延迟加载的浏览器，需要应用上述实现它的技术。\n\n为防止在下载延迟加载的图像时重排周围的内容，请确保将`height`和`width`属性添加到`<img>`元素或直接以内联样式指定它们的值：\n\n```html\n<img src=\"image1.jpg\" loading=\"lazy\" alt=\"…\" width=\"300\" height=\"300\">\n<img src=\"image2.jpg\" loading=\"lazy\" alt=\"…\" style=\"height:300px; width:300px;\">\n```\n\n### 延迟加载 CSS 背景图像\n\n在`<img />`标签之后，背景图片是在网页上加载图片的最常见方式。对于`<img />`标签，浏览器有一个非常简单的方法——如果图片 URL 可用，让我们加载图片。\n\n使用 CSS 背景图像并不是那么简单。为了加载 CSS 背景图像，浏览器需要构建 DOM（文档对象模型）树以及 CSSOM（CSS 对象模型）树，以决定 CSS 样式是否适用于当前文档中的 DOM 节点。\n\n如果指定背景图像的 CSS 规则不适用于文档中的元素，则浏览器不会加载背景图像。如果 CSS 规则适用于当前文档中的元素，则浏览器会加载图像。\n\n起初这可能看起来很复杂，但同样的行为构成了延迟加载背景图像技术的基础。简单来说，我们欺骗浏览器在元素进入视口之前不将背景图像 CSS 属性应用到元素。\n\n这是一个延迟加载 CSS 背景图像的工作示例。\n\n<iframe height=\"265\" width=\"100%\" scrolling=\"no\" title=\"在 CSS 中延迟加载背景图像\" src=\"https://codepen.io/imagekit_io/embed/RBXVrW?height=265&amp;theme-id=default&amp;default-tab=html,result\" style=\"box-sizing: inherit; margin: 0px auto !important; padding: 0px; border: 0px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-weight: 400; font-stretch: inherit; line-height: inherit; font-family: Georgia, serif; font-size: 20px; vertical-align: middle; color: rgb(49, 59, 63); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; width: 100%;\"></iframe>\n\n\n这里要注意的一件事是延迟加载的 Javascript 代码仍然是相同的。我们正在使用 Intersection Observer API 方法并回退到事件侦听器。诀窍在于CSS。\n\nID 为 bg-image 的元素`background-image`在 CSS 中指定了一个。但是，当类`lazy`被添加到这个元素时，在 CSS 中我们会覆盖该`background-image`属性并将其设置为无。\n\n由于规则，`#bg-image`与`.lazy`class 结合在 CSS 中比 just 具有更高的偏好，浏览器最初`#bg-image`将属性应用于元素。`background-image: none`当我们向下滚动时，Intersection Observer（或事件侦听器）检测到图像在视口中并删除 class `lazy`。这会更改适用的 CSS 并将实际`background-image`属性应用于触发背景图像加载的元素。\n\n\n## 延迟加载图像带来更好的用户体验\n\n延迟加载带来了巨大的性能优势。对于在页面上加载数百个产品图像的电子商务公司，延迟加载可以显着改善初始页面加载时间，同时减少带宽消耗。\n\n然而，很多公司并没有选择延迟加载，因为他们认为这不利于提供出色的用户体验，理由是“初始占位符很丑”、“加载时间很慢”等。\n\n我们如何通过延迟加载图像来解决有关用户体验的这些问题？\n\n### 1.使用正确的图像占位符\n\n占位符是在加载实际图像之前出现在容器中的内容。通常，我们看到开发人员使用纯色占位符来存储图像，或者使用单个图像作为所有图像的占位符。\n\n我们在示例代码中也使用了相同的方法。我们所有的图像背景都使用纯浅灰色。但是，我们可以做得更好，以提供更令人愉悦的用户体验。\n\n看看我们的图像更好的占位符的一些例子：\n\n#### **a) 主色占位符**\n\n我们不是使用固定颜色作为图像占位符，而是从原始图像中找到主要颜色并将其用作占位符。\n\n这种技术已经在谷歌图片搜索结果和 Pinterest 中使用了相当长的一段时间。\n\n\n这可能看起来很复杂，但实现这一点的一个非常简单的方法是首先将图像缩小到 1x1 像素，然后将其放大到占位符的大小 - 一个非常粗略的近似值，但很简单，没有大惊小怪获得单一主色的方法。\n\n#### **b) 低质量图像占位符 (LQIP)**\n\n我们可以进一步扩展上述使用主色占位符的想法。\n\n我们没有使用单一颜色，而是使用原始图像的质量非常低、模糊的版本作为占位符。它不仅看起来更好，还让用户对实际图像中的预期有所了解，同时给人一种图像加载正在进行的感觉。这对于改善感知加载体验非常有用。\n\nFacebook 和 Medium.com 等公司已将这种技术用于其网站和应用程序上的图像。\n\n**使用 ImageKit 的 LQIP 图像 URL 示例**\n\n```html\n<!-- Original image at 400x300 -->\n<img src=\"https://ik.imagekit.io/demo/img/image4.jpeg?tr=w-400,h-300\" alt=\"original image\" />\n\n<!-- Low quality image placeholder with same dimensions -->\n<img src=\"https://ik.imagekit.io/demo/img/image4.jpeg?tr=w-400,h-300,bl-30,q-50\" alt=\"dominant color placeholder\" />\n```\n\nLQIP 大小为 1300 字节，比原始图像小近 10 倍，在视觉体验方面比任何其他占位符技术都有显着改进。\n\n\n### 2.为图片加载增加一些缓冲时间\n\n当我们在上面讨论触发图像加载的不同方法时，我们检查了图像进入视口的时间点，即图像占位符的上边缘与视口的下边缘重合的时间点。\n\n**问题**\n通常，用户快速滚动页面，图像需要一些时间才能加载并出现在屏幕上。在这种情况下，再加上加载图像事件可能会因节流而延迟触发，您经常会遇到占位符进入视口的情况，用户在图像加载时等待几毫秒。这种延迟会导致糟糕的用户体验。\n\n虽然使用 Intersection Observers 加载图像或使用低质量的图像占位符可提供更好的加载性能和用户体验，但您可以使用另一个简单的技巧来确保图像在进入视口时始终完全加载 - 引入边距到图像的触发点。\n\n**解决方案**\n不是在图像完全进入视口时才加载图像，而是在图像距离进入视口 500 像素时加载图像。这在加载触发器和视口中的实际条目之间提供了额外的时间来加载图像。\n\n使用 Intersection Observer API，您可以使用 `root` 参数和 `rootMargin` 参数（作为标准 CSS 边距规则）来增加被认为找到“交叉点”的有效边界框。\n\n使用事件监听器方法，我们可以使用一个正数来添加一些阈值，而不是检查图像边缘和视口边缘之间的差异是否为 0。\n\n如果您还没有注意到，在我们所有的示例中，第三张图像 (image3.jpg) 总是在前面加载，即使它在视口之外。这也是按照相同的原则完成的 - 稍微提前加载而不是精确加载阈值以获得更好的用户体验。\n\n如果您使用的是原生图像延迟加载方法，浏览器会自动计算与视口阈值的距离，以确定浏览器何时应该触发图像加载。浏览器会考虑浏览器中的图像类型、网络速度和数据保护程序设置来确定此阈值，同时牢记开发人员的期望和用户体验。\n\n### 3.通过延迟加载避免内容转移\n\n这是另一个微不足道的问题，如果解决，可以帮助保持良好的用户体验。\n\n**问题**\n当没有图像时，浏览器不知道要在封闭容器中显示的内容的尺寸。如果我们不使用 CSS 指定它，封闭容器将没有尺寸，即 0 x 0 像素。因此，当图像被加载时，浏览器会调整封闭容器的大小以适应图像。\n这种布局的突然变化导致其他元素移动，这称为内容移动。正如 Smashing Magazine 的这篇[内容转换文章和视频](https://www.smashingmagazine.com/2016/08/ways-to-reduce-content-shifting-on-page-load/)中所展示的，当图像加载时内容突然移动，这对用户来说是一种相当不愉快的体验。\n\n**解决方案**\n这可以通过为封闭容器指定高度和/或宽度来避免，以便浏览器可以使用已知高度和宽度绘制图像容器。稍后，当图像加载时，由于已经指定了容器大小并且图像完全适合该大小，因此容器周围的其余内容保持不变。\n\n### 4.不要懒加载所有图片\n\n这是开发人员经常犯的另一个错误——延迟加载页面上的所有图像。这可能会减少初始页面加载，但也会导致糟糕的用户体验，因为很多图像，即使是网页顶部的图像，在 Javascript 执行之前都不会显示。\n\n以下是确定哪些图像应该延迟加载的一些一般原则。\n\n**a)**任何出现在视口中或网页开头的图像**都不**应延迟加载。这适用于任何标题图像、营销横幅、徽标等，因为用户应该在页面加载后立即看到它们。\n\n此外，由于移动设备和桌面设备具有不同的屏幕尺寸，它们最初会在屏幕上显示不同数量的图像。因此，您需要考虑设备类型来决定预先加载哪些资源以及延迟加载哪些资源。\n\n**b)**任何稍微偏离视口的图像都不应延迟加载。这是基于前面讨论的点 - 稍微提前加载。因此，比方说，任何 500 像素的图像或从视口底部开始的单个滚动也可以预先加载。\n\n**c)**如果页面不太长，可能只有一个或两个滚动条，或者视口外的图像少于 5 张，则可以完全避免延迟加载。\n\n就性能而言，它不会为最终用户提供任何显着的好处。您在页面上加载以启用延迟加载的附加 JS 将抵消延迟加载如此少量图像所带来的任何好处。\n\n\n## 延迟加载的 Javascript 依赖\n\n延迟加载的整个想法取决于用户浏览器中 Javascript 执行功能的可用性。尽管原生延迟加载承诺会消除这种依赖，但浏览器支持率仍接近 70%，但如果您要在所有浏览器中提供相同的体验，您仍然需要使用 JS 库。\n\n## 用于在您的网站上延迟加载的流行 Javascript 库\n\n由于浏览器环境和实现细节可能因浏览器和设备而异，因此最好使用经过验证的库来进行延迟加载。\n\n这是一个流行的库和特定于平台的插件的列表，它们可以让您以最小的努力实现延迟加载\n\n**[yall.js](https://github.com/malchata/yall.js)**\n\n- 使用 Intersection Observer 并回退到基于事件的延迟加载。\n- 支持所有主要的 HTML 元素类型，但不支持背景图像。\n- 也适用于 IE11+。\n\n**[lazysizes](https://github.com/aFarkas/lazysizes)**\n\n- 非常流行和广泛的功能。\n- 也支持响应式图像 srcset 和 sizes 属性。\n- 即使没有 Intersection Observer 也能实现高性能。\n\n**[jQuery Lazy](http://jquery.eisbehr.de/lazy/)**\n\n- 一个简单的、基于 jquery 的延迟加载库。\n\n**[WeltPixel Lazy Loading Enhanced](https://www.weltpixel.com/magento-2-lazy-loading-enhanced.html)**\n\n- 用于延迟加载图像的 Magento 2 扩展。\n\n**[Magento Lazy Image Loader](https://www.mgt-commerce.com/magento-lazy-load-images.html)**\n\n- 用于延迟加载图像的 Magento 1.x 扩展。\n\n**[Shopify Lazy Image Plugin](https://apps.shopify.com/lazy-image)**\n\n- 用于延迟加载图像的 Shopify 扩展。\n- 虽然是付费的。\n\n**[Wordpress A3 Lazy Load](https://wordpress.org/plugins/a3-lazy-load/)**\n\n- Wordpress 的图像延迟加载插件。\n\n## 如何测试延迟加载是否有效？\n\n实施延迟加载后，您需要检查网站上图像的行为是否符合预期。最简单的方法是在 Chrome 浏览器中打开开发者工具。\n\n转到网络选项卡 > 图像。\n\n在这里，当您第一次刷新页面时，只有要加载的图像才会被加载。然后，当您开始向下滚动页面时，将触发并加载其他图像加载请求。\n\n您还可以在此视图的瀑布列中注意到图像加载的时间。它将帮助您识别图像加载问题（如果有）或触发图像加载的问题。\n\n另一种方法是在实施更改后在您的页面上运行 Google Chrome Lighthouse 审核报告，并在[“屏幕外图像”](https://developers.google.com/web/tools/lighthouse/audits/offscreen-images)部分下查找建议。\n\n## 结论\n\n延迟加载如果实施得当，将显着提高网页的加载性能，通过减少预先加载的不必要资源来减少页面大小和交付成本，同时保持页面上必要内容的完整性。\n\n**<a href=\"./img-lazy.html\"  download=\"img-lazy.html\">DEMO</a>**"},{"title":"css父元素设置圆角,子元素遮挡解决方法","url":"/2022/09/20/css父元素设置圆角-子元素遮挡解决方法/","content":"\n- 父元素设置 `overflow:auto;`","tags":["css"]},{"title":"YAML文件是干什么的?","url":"/2022/07/15/YAML文件是干什么的/","content":"\nYAML 是 \"YAML Ain't a Markup Language\"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\"Yet Another Markup Language\"（仍是一种标记语言）。\n\nYAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。\n\nYAML 的配置文件后缀为 .yml\n\n## 基本语法\n\n- 大小写敏感\n- 使用缩进表示层级关系\n- 缩进时不允许使用Tab键，只允许使用空格。\n- 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可\n\n## 数据类型\n\n- 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）\n- 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）\n- 纯量（scalars）：单个的、不可再分的值\n\n## 对象\n\n```yml\ninfo:\n  version: \"1.0.0\"\n  title: \"CMAP website api\"\n```\n\n转换为js\n\n```js\ninfo: { version: '1.0.0', title: 'CMAP website api' }\n```\n\n第二种写法\n\n```yml\ninfo: {version: 1.0.0, title: CMAP website api}\n```\n\n转换为js\n\n```js\ninfo: { version: '1.0.0', title: 'CMAP website api' }\n```\n\n## 数组\n\n使用 `-`\n\n```yml\n  - name: \"Website\"\n  - name: \"Site\"\n  - name: \"Components\"\n  - name: \"Variation\"\n```\n转换成js\n\n```js\n  [\n    { name: 'Website' },\n    { name: 'Site' },\n    { name: 'Components' },\n    { name: 'Variation' }\n  ]\n```\n\n```yml\n-\n  - name: \"Website\"\n  - name: \"Site\"\n  - name: \"Components\"\n  - name: \"Variation\"\n```\n转换成js\n\n```js\n  [[\n    { name: 'Website' },\n    { name: 'Site' },\n    { name: 'Components' },\n    { name: 'Variation' }\n  ]]\n```\n\n```yml\ntags:\n  - name: \"Website\"\n  - name: \"Site\"\n  - name: \"Components\"\n  - name: \"Variation\"\n```\n\n转换成js\n\n```js\n  tags: [\n    { name: 'Website' },\n    { name: 'Site' },\n    { name: 'Components' },\n    { name: 'Variation' }\n  ]\n```\n\n## 复合结构\n\n```yml\nswagger: \"2.0\"\ninfo:\n  version: \"1.0.0\"\n  title: \"CMAP website api\"\nbasePath: \"/api\"\nhost: \"local.cmap.com\"\ntags:\n  - name: \"Website\"\n  - name: \"Site\"\n  - name: \"Components\"\n  - name: \"Variation\"\nschemes:\n  - http\n```\n\n转换成js\n\n```js\n{\n  swagger: '2.0',\n  info: { version: '1.0.0', title: 'CMAP website api' },\n  basePath: '/api',\n  host: 'local.cmap.com',\n  tags: [\n    { name: 'Website' },\n    { name: 'Site' },\n    { name: 'Components' },\n    { name: 'Variation' }\n  ],\n  schemes: [ 'http' ]\n}\n```\n\n## 转换code\n\n- 安装[`npm install js-yaml`](https://www.npmjs.com/package/js-yaml)\n\n_config.yml\n\n```yml\nswagger: \"2.0\"\ninfo:\n  version: \"1.0.0\"\n  title: \"CMAP website api\"\nbasePath: \"/api\"\nhost: \"local.cmap.com\"\ntags:\n  - name: \"Website\"\n  - name: \"Site\"\n  - name: \"Components\"\n  - name: \"Variation\"\nschemes:\n  - http\n```\n\ntransform.js\n\n```js\nconst yaml = require('js-yaml');\nconst fs = require('fs');\nconst path = require('path')\n// 读取yml文件\nconst ymlFile = fs.readFileSync(path.resolve(__dirname, '_config.yml'), { encoding: 'utf-8' })\n\nconst ymldata = yaml.load(ymlFile);\n\nconsole.log(ymldata);\n\n// {\n//   swagger: '2.0',\n//   info: { version: '1.0.0', title: 'CMAP website api' },\n//   basePath: '/api',\n//   host: 'local.cmap.com',\n//   tags: [\n//     { name: 'Website' },\n//     { name: 'Site' },\n//     { name: 'Components' },\n//     { name: 'Variation' }\n//   ],\n//   schemes: [ 'http' ]\n// }\n```\n\n> https://www.ruanyifeng.com/blog/2016/07/yaml.html","tags":["YMAL","YML"]},{"title":"什么是微服务?","url":"/2022/07/15/什么是微服务/","content":"\n> [https://www.ruanyifeng.com/blog/2022/04/microservice.html](https://www.ruanyifeng.com/blog/2022/04/microservice.html)","tags":["微服务"]},{"title":"函数组件使用context","url":"/2022/07/04/函数组件使用context/","content":"\n[https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext](https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext)\n\n直接上代码\n```js\nimport PropTypes from 'prop-types';\nimport { createContext, useState, useEffect } from 'react';\n// material\nimport { useMediaQuery } from '@material-ui/core';\nimport { useTheme } from '@material-ui/core/styles';\n\n// ----------------------------------------------------------------------\n// 定义provider的value\nconst initialState = {\n  collapseClick: false,\n  collapseHover: false,\n  onToggleCollapse: () => {},\n  onHoverEnter: () => {},\n  onHoverLeave: () => {},\n};\n\n// 定义context\nconst CollapseDrawerContext = createContext(initialState);\n\nCollapseDrawerProvider.propTypes = {\n  children: PropTypes.node,\n};\n\n// 封装provider\nfunction CollapseDrawerProvider({ children }) {\n  const theme = useTheme();\n  const isMobile = useMediaQuery(theme.breakpoints.down('lg'));\n  const [collapse, setCollapse] = useState({\n    click: false,\n    hover: false,\n  });\n\n  useEffect(() => {\n    if (isMobile) {\n      setCollapse({\n        click: false,\n        hover: false,\n      });\n    }\n  }, [isMobile]);\n\n  const handleToggleCollapse = () => {\n    setCollapse({ ...collapse, click: !collapse.click });\n  };\n\n  const handleHoverEnter = () => {\n    if (collapse.click) {\n      setCollapse({ ...collapse, hover: true });\n    }\n  };\n\n  const handleHoverLeave = () => {\n    setCollapse({ ...collapse, hover: false });\n  };\n\n  return (\n    <CollapseDrawerContext.Provider\n      value={{\n        isCollapse: collapse.click && !collapse.hover,\n        collapseClick: collapse.click,\n        collapseHover: collapse.hover,\n        onToggleCollapse: handleToggleCollapse,\n        onHoverEnter: handleHoverEnter,\n        onHoverLeave: handleHoverLeave,\n      }}\n    >\n      {children}\n    </CollapseDrawerContext.Provider>\n  );\n}\n\nexport { CollapseDrawerProvider, CollapseDrawerContext };\n```\n\n自定义钩子封装\n```js\nimport { useContext } from 'react';\nimport { CollapseDrawerContext } from '../contexts/CollapseDrawerContext';\n\n// ----------------------------------------------------------------------\n// 自定义useCollapseDrawer hook\nconst useCollapseDrawer = () => {\n  return useContext(CollapseDrawerContext);\n};\n\nexport default useCollapseDrawer;\n\n```\n\n函数组建使用定义的 `CollapseDrawerContext`\nindex.js\n```js\nReactDOM.render(\n  <StrictMode>\n    <CollapseDrawerProvider>\n        <App />\n    </CollapseDrawerProvider>\n  </StrictMode>,\n  document.getElementById('root'),\n);\n```\n函数组件中使用\n```js\n\nexport default function DocumentLayout() {\n  const {\n    isCollapse,\n    collapseClick,\n    collapseHover,\n    onHoverEnter,\n    onHoverLeave,\n  } = useCollapseDrawer();\n\n  return (\n    <div>\n        <button\n          onMouseEnter={onHoverEnter}\n          onMouseLeave={onHoverLeave}\n        ></button>\n    </div>\n  );\n}\n```","tags":["react context"]},{"title":"项目中用到的包","url":"/2022/07/01/项目中用到的包/","content":"\n* `npm i react-helmet-async`\n\n* `jss-rtl`\n  用于使用 JavaScript 生成样式表的库。\n\n* `framer-motion`\n* `nprogress` 进度条\n* [`mui`](https://mui.com/)"},{"title":"live2d部件模型","url":"/2022/06/29/live2d部件模型/","content":"\n<!-- # live2d部件模型 -->\n* live2d-widget-model-chitose\n  ![jnexG6.png](https://s1.ax1x.com/2022/06/29/jnexG6.png)\n\n* live2d-widget-model-epsilon2_1\n  ![jnmVit.png](https://s1.ax1x.com/2022/06/29/jnmVit.png)\n\n* live2d-widget-model-gf\n  ![jnmYWV.png](https://s1.ax1x.com/2022/06/29/jnmYWV.png)\n\n* live2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)\n* live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)\n\n\n* live2d-widget-model-haruto\n  ![jnn0c8.png](https://s1.ax1x.com/2022/06/29/jnn0c8.png)\n\n* live2d-widget-model-hibiki\n  ![jnu82V.png](https://s1.ax1x.com/2022/06/29/jnu82V.png)\n\n* live2d-widget-model-hijiki\n  ![jnu5Gt.png](https://s1.ax1x.com/2022/06/29/jnu5Gt.png)\n\n* live2d-widget-model-izumi\n  ![jnK0eg.png](https://s1.ax1x.com/2022/06/29/jnK0eg.png)\n\n* live2d-widget-model-koharu\n  ![jnKDoj.png](https://s1.ax1x.com/2022/06/29/jnKDoj.png)\n\n* live2d-widget-model-miku\n  ![jnKhmF.png](https://s1.ax1x.com/2022/06/29/jnKhmF.png)\n\n* live2d-widget-model-ni-j\n  ![jnKL6K.png](https://s1.ax1x.com/2022/06/29/jnKL6K.png)\n\n* live2d-widget-model-nico\n  ![jnMptA.png](https://s1.ax1x.com/2022/06/29/jnMptA.png)\n\n* live2d-widget-model-nietzsche\n  ![jnMF6f.png](https://s1.ax1x.com/2022/06/29/jnMF6f.png)\n\n* live2d-widget-model-nipsilon\n  ![jnMtAJ.png](https://s1.ax1x.com/2022/06/29/jnMtAJ.png)\n\n* live2d-widget-model-nito\n  ![jnMw1x.png](https://s1.ax1x.com/2022/06/29/jnMw1x.png)\n\n* live2d-widget-model-shizuku\n  ![jne7MF.png](https://s1.ax1x.com/2022/06/29/jne7MF.png)\n\n* live2d-widget-model-tororo\n  ![jnMsBD.png](https://s1.ax1x.com/2022/06/29/jnMsBD.png)\n\n* live2d-widget-model-tsumiki\n  ![jnMf3t.png](https://s1.ax1x.com/2022/06/29/jnMf3t.png)\n\n* live2d-widget-model-unitychan\n  ![jnM4jf.png](https://s1.ax1x.com/2022/06/29/jnM4jf.png)\n\n* live2d-widget-model-wanko\n  ![jnMq4s.png](https://s1.ax1x.com/2022/06/29/jnMq4s.png)\n\n* live2d-widget-model-z16\n  ![jnQnbD.png](https://s1.ax1x.com/2022/06/29/jnQnbD.png)\n\n* live2d-widget-model-kasumi\n  ![](https://camo.githubusercontent.com/099054215fd7a712eafc31b61a9e07902b59494a74cfcdaf02632e0a7f6092ef/68747470733a2f2f67697465652e636f6d2f417567753173746f2f696d616765486f73742f7261772f6d61737465722f426c6f67496d672f3230323131323136313832333933362e706e67)\n\n[https://github.com/xiazeyu/live2d-widget-models](https://github.com/xiazeyu/live2d-widget-models)","tags":["live2d","live2d部件模型"],"categories":["live2d"]},{"title":"react18 新特性","url":"/2022/06/29/react18-new-feature/","content":"\n## 自动批处理\n\n使用set函数时不会像之前执行一个set函数渲染一次界面(更改一个状态渲染一次界面)，会等到某一处理函数中set函数都执行完了之后渲染界面（只在最后渲染界面）\nexample\n```js\nconst handleClick = () =>{\n  setIsFetching(false);\n  setStatus('success');\n}\n\n// Before: only React events were batched.\nsetTimeout(() => {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n  // React will render twice, once for each state update (no batching)\n}, 1000);\n\n// After: updates inside of timeouts, promises,\n// native event handlers or any other event are batched.\nsetTimeout(() => {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n  // React will only re-render once at the end (that's batching!)\n}, 1000);\n```\n\n\n\n## 新的客户端和服务器渲染 API\n\n- createRoot\n\n```js\n// Before\nimport { render } from 'react-dom';\nconst container = document.getElementById('app');\nrender(<App tab=\"home\" />, container);\n\n// After\nimport { createRoot } from 'react-dom/client';\nconst container = document.getElementById('app');\nconst root = createRoot(container); // createRoot(container!) if you use TypeScript\nroot.render(<App tab=\"home\" />);\n```\n- hydrateRoot\n\n## [新功能 transition](https://reactjs.org/blog/2022/03/29/react-v18.html#new-feature-transitions)\n\nreact.memo\n\n## 支持 Suspense 的流式服务器端渲染\n\n某一组件先加载出来，某一组件后加载出来（服务端返回的html）,就可以使用Suspense，提升用户体验\nIn React 18, we’ve added support for Suspense on the server and expanded its capabilities using concurrent rendering features.\n\nSuspense in React 18 works best when combined with the transition API. If you suspend during a transition, React will prevent already-visible content from being replaced by a fallback. Instead, React will delay the render until enough data has loaded to prevent a bad loading state.\n```js\n// 该组件是动态加载的\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\n\nfunction MyComponent() {\n  return (\n    // 显示 <Spinner> 组件直至 OtherComponent 加载完成\n    <React.Suspense fallback={<Spinner />}>\n      <div>\n        <OtherComponent />\n      </div>\n    </React.Suspense>\n  );\n}\n```\n\n## 新的严格模式行为\n\n## 新的钩子\n\n* useId\n  useId用于在客户端和服务器上生成唯一 ID，同时避免水合不匹配。它主要用于与需要唯一 ID 的可访问性 API 集成的组件库。这解决了 React 17 及更低版本中已经存在的问题，但在 React 18 中更为重要，因为新的流式服务器渲染器如何无序交付 HTML。\n\n\n* useTransition\n* startTransition\n  useTransition并startTransition让您将一些状态更新标记为不紧急。默认情况下，其他状态更新被认为是紧急的。React 将允许紧急状态更新（例如，更新文本输入）以中断非紧急状态更新（例如，呈现搜索结果列表）。\n\n\n* useDeferredValue\n  useDeferredValue让您推迟重新渲染树的非紧急部分。它类似于去抖动，但与之相比有一些优点。没有固定的时间延迟，因此 React 将在第一次渲染反映在屏幕上后立即尝试延迟渲染。延迟渲染是可中断的，不会阻止用户输入。\n\n* useSyncExternalStore\n  useSyncExternalStore是一个新的钩子，它允许外部存储通过强制对存储的更新同步来支持并发读取。在实现对外部数据源的订阅时，它消除了对 useEffect 的需要，并且推荐用于任何与 React 外部状态集成的库。\n\n* useInsertionEffect\n  useInsertionEffect它允许 CSS-in-JS 库解决在渲染中注入样式的性能问题。除非您已经构建了 CSS-in-JS 库，否则我们不希望您使用它。这个钩子将在 DOM 发生变异之后运行，但在布局效果读取新布局之前。这解决了在 React 17 及更低版本中已经存在的问题，但在 React 18 中更为重要，因为 React 在并发渲染期间屈服于浏览器，使其有机会重新计算布局。\n\n\n## [详细更新日志](https://github.com/facebook/react/blob/main/CHANGELOG.md#1800-march-29-2022)","tags":["react","react18"]},{"title":"drupal主题更改,相关配置","url":"/2022/06/27/drupal主题更改-相关配置/","content":"\n# Drupal 主题设置\n\n## 使用 DDEV 安装 Drupal 环境\n- 安装ddev\n  ```bash\n  $ curl -LO https://raw.githubusercontent.com/drud/ddev/master/scripts/install_ddev.sh && bash install_ddev.sh\n  ```\n- 搭建环境 # Replace my-site-name\n  ```bash\n  $ export SITE_NAME=my-site-name\n\n  $ mkdir $SITE_NAME\n\n  $ cd $SITE_NAME\n\n  $  ddev config --project-type=drupal9 --project-name $SITE_NAME --docroot=web --create-docroot\n  ```\n- 启动 DDEV 容器\n  ```bash\n  $ ddev start\n  ```\n- 创建drupal应用程序\n  - 如果您的机器上没有安装 Composer，到官网上下载安装，或者使用`my-site-nameddev composer`\n- 开始安装\n  ```bash\n  $ ddev composer create \"drupal/recommended-project\"\n\n  $ ddev composer require drush/drush\n  ```\n- 安装drupal\n  ```bash\n  $ ddev drush site:install --account-name=admin --account-pass=admin\n\n  $ ddev launch\n  ```\n- 安装开发生成模块\n  - 下载并安装Devel Generate 模块（Devel 项目的一部分）并使用它来生成一些示例内容\n  ```bash\n  $ ddev composer require drupal/devel\n\n  $ ddev drush en devel_generate\n  ```\n  - **没有ddev安装**\n  ```bash\n  $ composer require drupal/devel\n\n  $ drush en devel_generate\n  ```\n- 生成用户、标签和内容\n  Devel Generate 带有自定义 Drush 命令，我们可以使用这些命令来生成用户、标签和内容。我们建议您按以下顺序运行命令，以便将您生成的内容分配给随机用户以模拟更真实的体验。\n  ```bash\n  $ ddev drush devel-generate-users 10\n  $ ddev drush devel-generate-terms 20 --bundles tags --max-depth 1\n  $ ddev drush devel-generate-content 25\n  ```\n (optional)  (required in Drupal 9, optional for Drupal 8)  (optional)  (optional)  (optional)  (optional)  (optional)  (optional)  (optional)  (deprecated)  (optional)\n\n## 建立主题\n- 在`web/themes`目录下建立自己的主题`reboot`文件夹\n  ![jCpZQA.png](https://s1.ax1x.com/2022/06/23/jCpZQA.png)\n- 在reboot文件夹下面创建`reboot.info.yml`(命名规范必须是THEME.info.yml)\n- `THEME.info.yml`文件配置属性\n  | 参数                 | 是否必填                                                                    | 描述                                                                                                                                                                                                    |\n  | -------------------- | --------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n  | name                 | 是                                                                          | 主题名称                                                                                                                                                                                                |\n  | type                 | 是                                                                          | 表示扩展的类型，\"module\", \"theme\", or \"profile\"对于主题，应始终将其设置为“主题”。此值区分大小写。                                                                                                       |\n  | description          | 否                                                                          | 主题描述信息                                                                                                                                                                                            |\n  | dependencies         | 否                                                                          | 一个依赖字符串数组，在 8.9.x 中引入。                                                                                                                                                                   |\n  | package              | 否                                                                          | 指定允许您将主题组合在一起的“包”。                                                                                                                                                                      |\n  | core                 | Drupal 8所需的，如果包含 core _ version _ request 则为可选，对 Drupal 9无效 | 指定主题兼容的 Drupal 核心版本。                                                                                                                                                                        |\n  | php                  | 否                                                                          | 所需的最低 PHP 版本。默认为`DRUPAL_MINIMUM_PHP`常量的值。                                                                                                                                               |\n  | version              | 否                                                                          | 指定版本。对于托管在 drupal.org 上的主题，版本号将由打包脚本填写。不要手动指定它，而是完全省略版本行。                                                                                                  |\n  | libraries            | 否                                                                          | 要添加到主题处于活动状态的所有页面的库列表（可以包含 CSS 和 JavaScript 资产）                                                                                                                           |\n  | libraries-override   | 否                                                                          | 要覆盖的库和资产的集合，[更多内容覆盖和扩展库](https://www.drupal.org/node/2216195#override-extend)                                                                                                     |\n  | libraries-extend     | 否                                                                          | 附加库时要添加的库和资产的集合                                                                                                                                                                          |\n  | base theme           | Drupal9必须, Drupal8可选                                                    | 一个主题可以通过将其指定为基本主题来继承另一个主题的资源。建议使用 classy 或 stable9（如果使用 Drupal 8 则为 stable）。如果设置为 false，则不使用基本主题。                                             |\n  | hidden               | 否                                                                          | 指示是否从“外观”页面隐藏主题，使其无法通过 UI 启用/禁用。                                                                                                                                               |\n  | engine               | 否                                                                          | 主题引擎。默认为“twig”。                                                                                                                                                                                |\n  | logo                 | 否                                                                          | logo相对于主题文件的路径。默认情况下，Drupal 将在主题文件夹的根目录中查找名为“logo.svg”的文件并将其用作主题的logo。 .info.yml                                                                           |\n  | screenshot           | 否                                                                          | 相对于主题文件的截图路径。屏幕截图应为 588 像素宽和 438 像素高，尽管它们以较小的尺寸显示。默认情况下，Drupal 将在主题文件夹的根目录中查找名为“screenshot.png”的文件，并将其用作“外观”页面上的主题图像。 |\n  | regions              | 否                                                                          | 主题区域列表。（请注意，区域键前面没有破折号。）content区域是必需的。阅读有关将区域添加到主题的更多信息。                                                                                               |\n  | regions_hidden       | 否                                                                          | 要删除的继承区域列表。                                                                                                                                                                                  |\n  | features             | 否                                                                          | 在主题“设置”页面上公开的功能列表。                                                                                                                                                                      |\n  | ckeditor_stylesheets | 否                                                                          | 要添加到 CKEditor 框架的样式表列表。                                                                                                                                                                    |\n\n配置好主题之后会在界面的后台找到\n![jCAIER.md.png](https://s1.ax1x.com/2022/06/23/jCAIER.md.png)\n\n## 配置regions\n区域在主题的.info.yml文件中表示为键/值对，其中键是用于在代码中标识区域的区域的内部名称，值是用户界面在识别地区。出于这个原因，使用在代码和 UI 中都有意义的键/值对和区域名称非常重要，这样任何人都可以轻松理解预期用途。\n\n区域的内容由放置在当前正在查看的页面上可见的区域中的任何块组成，并且通常在包装标记内的主题的page.html.twig模板文件中输出，就像div旨在提供布局和结构一样。\n- `info.yml`\n  ```yml\n  regions:\n    header: Header1\n    primary_menu: Primary menu1\n    secondary_menu: Secondary menu1\n    page_top: Page top1\n    page_bottom: Page bottom1\n    highlighted: Highlighted1\n    featured_top: Featured top1\n    breadcrumb: Breadcrumb1\n    content: Content1\n    sidebar_first: Sidebar first1\n    sidebar_second: Sidebar second1\n    footer_first: Footer first1\n    footer_second: Footer second1\n    + aaa_content: AAA content\n  ```\n- `page.html.twig`(建templates文件夹，把page.html.twig复制进来) 修改内容\n  ![jCm4ts.md.png](https://s1.ax1x.com/2022/06/23/jCm4ts.md.png)\n\n## 资源模块，外部内部引用\n\nAsset Libraries是THEMENAME.libraries.yml文件中的 YAML 数据结构，它指定一个或多个 CSS 和 JavaScript 文件及其设置，并以唯一标识的库名称捆绑在一起。一旦定义了库，将其添加到页面或将其附加到特定类型的元素，无论库的内容如何，​​都以相同的方式完成。这意味着现在有一种统一的机制来添加 CSS 和 JavaScript，无论是添加到模块还是主题中。\n\n- `THEMENAME.libraries.yml`\n  声明模块 aaa、bbb、ccc，模块中定义需要用到的js、css、依赖包等,\n  加载顺序按照文件列出顺序加载\n  ```yml\n  # aaa模块\n  aaa:\n    version: 1.0\n    css:\n      theme:\n        css/aaa.css: {}\n    header: true # 设置在头部先加载\n    js:\n      js/aaa.js: {}\n\n  # bbb模块\n  bbb:\n    version: 1.0\n    css:\n      theme:\n        css/bbb.css: {}\n    js:\n      js/bbb.js: {}\n\n  # ccc模块\n  ccc:\n    version: 1.0\n    remote: https://github.com/xoxco/rainbow-text\n    license:\n      name: MIT\n      url: https://github.com/xoxco/Rainbow-Text/blob/master/README.md\n      gpl-compatible: true\n    css:\n      theme:\n        css/ccc.css: {}\n    js:\n      js/ccc.js: {}\n    dependencies: # 声明依赖\n      - core/jquery\n      - my_module/my_library\n      - my_theme/my_library\n  ```\n  - **remote：** 如果库是第三方脚本，则提供存储库 URL 以供参考。\n  - **license：** 如果设置了remote属性，则需要license信息。它有 3 个属性：\n    - **名称：** 许可证的可读名称。\n    - **url：** 所用库版本的许可文件/信息的 URL。\n    - **gpl-compatible：** 此库是否与 GPL 兼容的布尔值。\n- 定义的模块如何使用\n  - 全局使用\n    在`THEME.info.yml`libraries引入\n    ```yml\n     libraries:\n      - reboot/aaa\n      - reboot/bbb\n      - reboot/ccc\n    ```\n    ![jClcXq.md.png](https://s1.ax1x.com/2022/06/23/jClcXq.md.png)\n  - 特定页面使用\n    在`THEME.theme`,首页使用aaa模块\n    ```php\n    <?php\n    /**\n    * Implements hook_preprocess_page() for PAGE document templates.\n    */\n    function reboot_preprocess_page(&$variables) {\n      if ($variables['is_front'] == TRUE) {\n        $variables['#attached']['library'][] = 'reboot/aaa';\n      }\n    }\n\n    ```\n    ![jERjKS.md.png](https://s1.ax1x.com/2022/06/27/jERjKS.md.png)\n\n---\n\n## 为主题开发配置环境\n![jEfdw4.md.png](https://s1.ax1x.com/2022/06/27/jEfdw4.md.png)\n![jEfrf1.md.png](https://s1.ax1x.com/2022/06/27/jEfrf1.md.png)\n![jEfgOO.md.png](https://s1.ax1x.com/2022/06/27/jEfgOO.md.png)\n![jEffTH.md.png](https://s1.ax1x.com/2022/06/27/jEffTH.md.png)\n\n---\n\n## 什么是模板文件？Drupal 如何确定使用哪个模板？\n![jE4jWn.md.png](https://s1.ax1x.com/2022/06/27/jE4jWn.md.png)\n![jE5eQx.md.png](https://s1.ax1x.com/2022/06/27/jE5eQx.md.png)\n![jE5QTe.md.png](https://s1.ax1x.com/2022/06/27/jE5QTe.md.png)\n![jE58fA.md.png](https://s1.ax1x.com/2022/06/27/jE58fA.md.png)\n![jE5wTg.md.png](https://s1.ax1x.com/2022/06/27/jE5wTg.md.png)\n![jE5H6x.md.png](https://s1.ax1x.com/2022/06/27/jE5H6x.md.png)\n\n---\n\n## 覆盖模板文件\n![jETxNF.md.png](https://s1.ax1x.com/2022/06/27/jETxNF.md.png)\n![jE7VAO.md.png](https://s1.ax1x.com/2022/06/27/jE7VAO.md.png)\n\n---\n\n## 确定模板的基本名称\n![jV95Sx.md.png](https://s1.ax1x.com/2022/06/27/jV95Sx.md.png)\n![jV9TOO.md.png](https://s1.ax1x.com/2022/06/27/jV9TOO.md.png)\n![jV9xpt.md.png](https://s1.ax1x.com/2022/06/27/jV9xpt.md.png)\n","tags":["drupal主题"]},{"title":"hexo博客搭建，主题配置","url":"/2022/06/17/hexo博客搭建主题配置/","content":"\n文档 [https://hexo.io/zh-cn/docs/](https://hexo.io/zh-cn/docs/)\n\n\n## 1.准备工作\n本地下载安装 *[nodejs](http://nodejs.cn/download/)*\n\n安装hexo-cli\n```javascript\n& npm install -g hexo-cli\n```\n\n## 2.初始化\n本地新建一个文件夹Blob,终端输入下面命令，或者手动创建文件夹\n```javascript\n$ mkdir Blob\n```\n```javascript\n$ hexo init Blob\n```\n\n初始化完成之后\n```javascript\n$ cd Blob\n```\n```javascript\n$ npm install\n```\n```javascript\n$ hexo s\n```\n![Alt](aaa.png)\n\n访问http://localhost:4000/\n\n## 3.hexo 常用命令\n\n\n| 命令                           | 描述                                                                            |\n| ------------------------------ | ------------------------------------------------------------------------------- |\n| hexo init [folder]             | 初始化博客,将博客基本模块下载到本地folder下面                                   |\n| hexo new [layout] [blob title] | 创建博客文章，layout指定使用布局，不指定则使用默认布局，blob title 博客文章标题 |\n| hexo clean                     | 清理缓存文件（db.json）和生成的public                                           |\n| hexo s 或 hexo server          | 本地启动站点，访问localhost:4000                                                |\n| hexo g 或 hexo generate        | 生成部署前的站点                                                                |\n| hexo d 或 hexo devlop          | 部署站点                                                                        |\n| hexo d -g 或 hexo devlop -g    | 部署站点前，先生成再部署                                                        |\n\n## 4.站点配置\n配置文件 `_config.yml`\n\n**基本配置：**\n\n| 参数        | 描述                                                                                                                                                 |\n| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |\n| title       | 网站标题                                                                                                                                             |\n| subtitle    | 网站副标题                                                                                                                                           |\n| description | 网站描述                                                                                                                                             |\n| keywords    | 网站的关键词。支持多个关键词。                                                                                                                       |\n| author      | 您的名字                                                                                                                                             |\n| language    | 网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。                 |\n| timezone    | 网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。 |\n\n**部署配置：**\n介绍部署导github:远程创建好仓库，不知道的可以看看[使用 Jekyll 创建 GitHub Pages 站点](https://docs.github.com/cn/pages/setting-up-a-github-pages-site-with-jekyll/creating-a-github-pages-site-with-jekyll)\n安装\n```javascript\n$ npm install hexo-deployer-git --save\n```\n修改配置文件\n```yml\ndeploy:\n  type: git\n  repo: <repository url> # https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io\n  branch: [branch]\n  message: [message]\n```\n| 参数    | 描述                                  | 默认值                                    |\n| ------- | ------------------------------------- | ----------------------------------------- |\n| repo    | github仓库地址(上面新建的带.io的仓库) |\n| branch  | 分支名称                              | 默认master                                |\n| message | 部署的时候的提交信息                  | 默认是站点更新日期：'YYYY-MM-DD HH:mm:ss' |\n| token   | 令牌                                  |\n\n最后执行部署\n``` javascript\n$ hexo d\n```\n\n访问站点(一般要等上几分钟才会出现内容)\nyourname.github.io\n\n## 5.主题更换\n\n下载安装主题\n这里使用一款简约的主题[yilia](https://github.com/litten/hexo-theme-yilia)\n将主题clone到themes文件夹下面\n```javascript\n$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n`_config.yml`更改配置（默认是landscape）\n```yml\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: yilia\n```\n本地查看\n```bash\n$ hexo clean\n$ hexo s\n```\n远程部署\n```bash\n$ hexo g\n$ hexo d\n```\n","tags":["hexo博客搭建"]}]